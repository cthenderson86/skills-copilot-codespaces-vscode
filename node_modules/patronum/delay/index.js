import { createEffect, createEvent, is, sample, combine } from 'effector';
export function delay(_ref) {
  var {
    source,
    timeout,
    target = createEvent({
      name: "target",
      sid: "-83bfmt"
    }, {
      name: "target",
      sid: "-83bfmt"
    })
  } = _ref;
  var targets = Array.isArray(target) ? target : [target];
  if (!is.unit(source)) throw new TypeError('source must be a unit from effector');
  if (!targets.every(unit => is.unit(unit))) throw new TypeError('target must be a unit from effector');
  var ms = validateTimeout(timeout);
  var timerFx = createEffect(_ref2 => {
    var {
      payload,
      milliseconds
    } = _ref2;
    return new Promise(resolve => {
      setTimeout(resolve, milliseconds, payload);
    });
  }, {
    name: "timerFx",
    sid: "crkyrv"
  });
  sample({
    and: [{
      // ms can be Store<number> | number
      // converts object of stores or object of values to store
      source: combine({
        and: [{
          milliseconds: ms
        }],
        or: {
          name: "source",
          sid: "-vx03ze"
        }
      }),
      clock: source,
      fn: (_ref3, payload) => {
        var {
          milliseconds
        } = _ref3;
        return {
          payload,
          milliseconds: typeof milliseconds === 'function' ? milliseconds(payload) : milliseconds
        };
      },
      target: timerFx
    }],
    or: {
      sid: "-vofthe"
    }
  });
  sample({
    and: [{
      clock: timerFx.doneData,
      target: targets
    }],
    or: {
      sid: "-uu74uj"
    }
  });
  return target;
}
function validateTimeout(timeout) {
  if (is.store(timeout, {
    sid: "-udpazz"
  }) || typeof timeout === 'function' || typeof timeout === 'number') {
    return timeout;
  }
  throw new TypeError("'timeout' argument must be a function, Store, or a number. Passed \"".concat(typeof timeout, "\""));
}