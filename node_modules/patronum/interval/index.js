import { createEvent, createStore, guard, sample, attach, is } from 'effector';
export function interval(_ref) {
  var {
    timeout,
    start,
    stop,
    leading = false,
    trailing = false
  } = _ref;
  var setup = start !== null && start !== void 0 ? start : createEvent({
    name: "setup",
    sid: "-ajedhm"
  });
  var teardown = stop !== null && stop !== void 0 ? stop : createEvent({
    name: "teardown",
    sid: "-ryi8gr"
  });
  var tick = createEvent({
    name: "tick",
    sid: "-cw8a02"
  });
  var $isRunning = createStore(false, {
    name: "$isRunning",
    sid: "-5gspmy"
  });
  var $timeout = toStoreNumber(timeout);
  var $notRunning = $isRunning.map(running => !running);
  var saveTimeout = createEvent({
    name: "saveTimeout",
    sid: "satd6r"
  });
  var $timeoutId = createStore(null, {
    name: "$timeoutId",
    sid: "hehxq7"
  }).on(saveTimeout, (_, _ref2) => {
    var {
      timeoutId
    } = _ref2;
    return timeoutId;
  });
  // eslint-disable-next-line @typescript-eslint/no-empty-function
  var $rejecter = createStore(() => {}, {
    name: "$rejecter",
    sid: "-sc3eh9"
  }).on(saveTimeout, (_, _ref3) => {
    var {
      reject
    } = _ref3;
    return reject;
  });
  var timeoutFx = attach({
    and: {
      source: {
        timeout: $timeout,
        running: $isRunning
      },
      effect: _ref4 => {
        var {
          timeout,
          running
        } = _ref4;
        if (!running) {
          return Promise.reject();
        }
        return new Promise((resolve, reject) => {
          var timeoutId = setTimeout(resolve, timeout);
          saveTimeout({
            timeoutId,
            reject
          });
        });
      }
    },
    or: {
      name: "timeoutFx",
      sid: "-xlxric"
    }
  });
  var cleanupFx = attach({
    and: {
      source: {
        timeoutId: $timeoutId,
        rejecter: $rejecter
      },
      effect: _ref5 => {
        var {
          timeoutId,
          rejecter
        } = _ref5;
        rejecter();
        if (timeoutId) clearTimeout(timeoutId);
      }
    },
    or: {
      name: "cleanupFx",
      sid: "-32ewxw"
    }
  });
  guard({
    and: [{
      clock: setup,
      source: $timeout,
      filter: $notRunning,
      target: timeoutFx
    }],
    or: {
      sid: "-us95i7"
    }
  });
  if (leading) {
    var onReady = guard({
      and: [{
        clock: setup,
        filter: $notRunning
      }],
      or: {
        name: "onReady",
        sid: "farho0"
      }
    });
    sample({
      and: [{
        clock: onReady,
        target: tick
      }],
      or: {
        sid: "-ubrbnn"
      }
    });
  }
  sample({
    and: [{
      clock: setup,
      fn: () => true,
      target: $isRunning
    }],
    or: {
      sid: "-ua3xxa"
    }
  });
  guard({
    and: [{
      clock: timeoutFx.done,
      source: $timeout,
      filter: $isRunning,
      target: timeoutFx
    }],
    or: {
      sid: "6lcmx8"
    }
  });
  guard({
    and: [{
      clock: timeoutFx.done,
      filter: $isRunning,
      target: tick.prepend(() => {
        /* to be sure, nothing passed to tick */
      })
    }],
    or: {
      sid: "6p772r"
    }
  });
  if (trailing) {
    sample({
      and: [{
        clock: teardown,
        target: tick
      }],
      or: {
        sid: "75p0xb"
      }
    });
  }
  $isRunning.on(teardown, () => false);
  sample({
    and: [{
      clock: teardown,
      target: cleanupFx
    }],
    or: {
      sid: "7ln232"
    }
  });
  return {
    tick,
    isRunning: $isRunning,
    '@@trigger': () => ({
      setup,
      teardown,
      fired: tick
    })
  };
}
function toStoreNumber(value) {
  if (is.store(value, {
    sid: "8i2x6t"
  })) return value;
  if (typeof value === 'number') {
    return createStore(value, {
      and: {
        name: '$timeout'
      },
      sid: "-jluixv"
    });
  }
  throw new TypeError("timeout parameter in interval method should be number or Store. \"".concat(typeof value, "\" was passed"));
}

/**
 * @see {@link https://withease.pages.dev/protocols/trigger.html}
 */