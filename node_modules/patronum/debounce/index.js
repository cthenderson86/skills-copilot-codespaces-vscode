import { createEffect, createEvent, createStore, is, sample, attach, guard, merge } from 'effector';
export function debounce(_ref) {
  var {
    source,
    timeout,
    target
  } = _ref;
  if (!is.unit(source)) throw new TypeError('source must be unit from effector');
  if (is.domain(source, {
    sid: "k76nst"
  })) throw new TypeError('source cannot be domain');
  var $timeout = toStoreNumber(timeout);
  var saveTimeoutId = createEvent({
    name: "saveTimeoutId",
    sid: "vsg63k"
  });
  var $timeoutId = createStore(null, {
    and: {
      serialize: 'ignore'
    },
    name: "$timeoutId",
    sid: "lhz3ie"
  }).on(saveTimeoutId, (_, id) => id);
  var saveReject = createEvent({
    name: "saveReject",
    sid: "qddkx3"
  });
  // eslint-disable-next-line @typescript-eslint/no-empty-function
  var $rejecter = createStore(null, {
    and: {
      serialize: 'ignore'
    },
    name: "$rejecter",
    sid: "-o8m8p2"
  }).on(saveReject, (_, rj) => rj);
  var tick = target !== null && target !== void 0 ? target : createEvent({
    name: "tick",
    sid: "a51tok"
  });
  var timerBaseFx = createEffect(_ref2 => {
    var {
      timeout,
      timeoutId,
      rejectPromise
    } = _ref2;
    if (timeoutId) clearTimeout(timeoutId);
    if (rejectPromise) rejectPromise();
    return new Promise((resolve, reject) => {
      saveReject(reject);
      saveTimeoutId(setTimeout(resolve, timeout));
    });
  }, {
    name: "timerBaseFx",
    sid: "-6dos97"
  });
  var timerFx = attach({
    and: {
      name: "debounce(".concat(source.shortName || source.kind, ") effect"),
      source: {
        timeoutId: $timeoutId,
        rejectPromise: $rejecter
      },
      mapParams: (timeout, _ref3) => {
        var {
          timeoutId,
          rejectPromise
        } = _ref3;
        return {
          timeout,
          timeoutId,
          rejectPromise
        };
      },
      effect: timerBaseFx
    },
    or: {
      name: "timerFx",
      sid: "ca9mop"
    }
  });
  $rejecter.reset(timerFx.done);
  $timeoutId.reset(timerFx.done);

  // It's ok - nothing will ever start unless source is triggered
  var $payload = createStore([], {
    and: {
      serialize: 'ignore'
    },
    name: "$payload",
    sid: "kaji03"
  }).on(source, (_, payload) => [payload]);
  var $canTick = createStore(true, {
    and: {
      serialize: 'ignore'
    },
    name: "$canTick",
    sid: "-gzi9li"
  });
  var triggerTick = createEvent({
    name: "triggerTick",
    sid: "3ifzes"
  });
  $canTick.on(triggerTick, () => false).on([tick,
  // debounce timeout should be restarted on timeout change
  $timeout,
  // debounce timeout can be restarted in later ticks
  timerFx], () => true);
  var requestTick = merge([source,
  // debounce timeout is restarted on timeout change
  guard({
    and: [{
      clock: $timeout,
      filter: timerFx.pending
    }],
    or: {
      name: "requestTick",
      sid: "pubo1h"
    }
  })], {
    name: "requestTick",
    sid: "8eq3mx"
  });
  guard({
    and: [{
      clock: requestTick,
      filter: $canTick,
      target: triggerTick
    }],
    or: {
      sid: "-1lskya"
    }
  });
  sample({
    and: [{
      source: $timeout,
      clock: triggerTick,
      target: timerFx
    }],
    or: {
      sid: "-1ihte4"
    }
  });
  sample({
    and: [{
      source: $payload,
      clock: timerFx.done,
      fn: _ref4 => {
        var [payload] = _ref4;
        return payload;
      },
      target: tick
    }],
    or: {
      sid: "-13nddd"
    }
  });
  return tick;
}
function toStoreNumber(value) {
  if (is.store(value, {
    sid: "-m1yad"
  })) return value;
  if (typeof value === 'number') {
    if (value < 0 || !Number.isFinite(value)) throw new Error("timeout must be positive number or zero. Received: \"".concat(value, "\""));
    return createStore(value, {
      and: {
        name: '$timeout'
      },
      sid: "-67guyq"
    });
  }
  throw new TypeError("timeout parameter in interval method should be number or Store. \"".concat(typeof value, "\" was passed"));
}