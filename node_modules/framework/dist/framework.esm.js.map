{"version":3,"file":"framework.esm.js","sources":["../node_modules/patronum/split-map/index.js","../src/hatch.ts","../src/browser-application.ts","../src/navigation.ts","../src/contract/index.ts","../src/default-domain.ts","../src/index.ts"],"sourcesContent":["import { is } from 'effector';\nexport function splitMap(_ref) {\n  var {\n    source,\n    cases\n  } = _ref;\n  var result = {};\n  var current = is.store(source, {\n    name: \"current\",\n    sid: \"-htjkz7\"\n  }) ? source.updates : source;\n\n  for (var key in cases) {\n    if (key in cases) {\n      (function () {\n        var _fn = cases[key];\n        result[key] = current.filterMap(_fn);\n        current = current.filter({\n          fn: data => !_fn(data)\n        });\n      })();\n    }\n  } // eslint-disable-next-line no-underscore-dangle\n\n\n  result.__ = current;\n  return result;\n}","import * as React from 'react';\nimport { Domain, Event, Store, combine, is } from 'effector';\nimport { MatchedRoute } from 'react-router-config';\n\nimport { defaultDomain } from './default-domain';\n\nconst HATCH = 'framework/page-hatch';\n\nexport interface HatchParams {\n  params: Record<string, string>;\n  query: Record<string, string>;\n}\n\n/**\n * Hatch is like a Gate, but just for models\n */\nexport interface Hatch {\n  // Called by history from withHatch\n  enter: Event<HatchParams>;\n  update: Event<HatchParams>;\n  exit: Event<void>;\n\n  $opened: Store<boolean>;\n  $params: Store<Record<string, string>>;\n  $query: Store<Record<string, string>>;\n\n  $props: Store<HatchParams>;\n}\n\ninterface Config {\n  enter: Event<HatchParams>;\n  update: Event<HatchParams>;\n  exit: Event<void>;\n  domain?: Domain;\n}\n\n/**\n * Events here is an input signal, history should call them when route enters, updates, and exits.\n * Stores is derived from this events and holds specific parameters\n * `$opened` holds current state of page, if user visited page but not left, it is `true`\n */\nexport function createHatch(config_: Config | Domain = defaultDomain): Hatch {\n  let domain;\n  let config: Partial<Config>;\n  if (is.domain(config_)) {\n    domain = config_;\n    config = {};\n  } else if (is.domain(config_.domain)) {\n    domain = config_.domain;\n    config = config_;\n  } else {\n    domain = defaultDomain;\n    config = {};\n  }\n\n  const $opened = domain.createStore(Boolean(false));\n  const $params = domain.createStore<Record<string, string>>({});\n  const $query = domain.createStore<Record<string, string>>({});\n\n  const hatch = {\n    enter: config.enter ?? domain.createEvent<HatchParams>(),\n    update: config.update ?? domain.createEvent<HatchParams>(),\n    exit: config.exit ?? domain.createEvent<void>(),\n    $opened,\n    $params,\n    $query,\n    $props: combine({ params: $params, query: $query }),\n  };\n\n  $params.on([hatch.enter, hatch.update], (_, { params }) => params);\n  $query.on([hatch.enter, hatch.update], (_, { query }) => query);\n\n  hatch.$opened.on(hatch.enter, () => Boolean(true)).reset(hatch.exit);\n  // Developer may want to read props when user leaves the page\n  // if $opened store will reset on hatch.exit, data will be deleted\n\n  return hatch;\n}\n\nexport function withHatch<C extends React.ComponentType>(hatch: Hatch, component: C): C {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  (component as any)[HATCH] = hatch;\n  return component;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function getHatch<T extends React.ComponentType<any>>(component: T): Hatch | undefined {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  return (component as any)[HATCH];\n}\n\nexport function lookupHatch<P>(match: MatchedRoute<P>): Hatch | undefined {\n  if (match.route.component) {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    return getHatch(match.route.component as any);\n  }\n}\n","import { Domain, Event, combine, forward, guard } from 'effector';\nimport { RouteConfig, matchRoutes } from 'react-router-config';\nimport { splitMap } from 'patronum/split-map';\n\nimport { HatchParams, getHatch } from './hatch';\nimport { createNavigation } from './navigation';\nimport { defaultDomain } from './default-domain';\n\n// eslint-disable-next-line sonarjs/cognitive-complexity\nexport function createBrowserApplication(config: {\n  ready: Event<void>;\n  routes: RouteConfig[];\n  domain?: Domain;\n}) {\n  const domain = config.domain || defaultDomain;\n  const navigation = createNavigation(domain, { emitHistory: true });\n  forward({ from: config.ready, to: navigation.historyEmitCurrent });\n\n  const routeResolved = navigation.historyChanged.filterMap((change) => {\n    const routes = matchRoutes(config.routes, change.pathname);\n\n    if (routes.length > 0) {\n      return {\n        ...routes[0],\n        change,\n      };\n    }\n  });\n\n  for (const { component, path } of config.routes) {\n    if (!component) continue;\n    if ((component as any).load) {\n      throw new Error(\n        `[${path}] lazy components temporary is not supported. Please, remove loadable() call`,\n      );\n    }\n\n    const { routeMatched, __: notMatched } = splitMap({\n      source: routeResolved,\n      cases: {\n        routeMatched: ({ route, match, change }) => {\n          if (route.path === path) {\n            return {\n              // route.path contains params, like /user/:userId\n              // :userId is a param\n              // match.params contains parsed params values\n              // /user/123 will be parsed as { userId: 123 }\n              params: match.params,\n              query: Object.fromEntries(new URLSearchParams(change.search)),\n            };\n          }\n          return undefined;\n        },\n      },\n    });\n\n    const hatchEnter = domain.createEvent<HatchParams>({ name: `hatchEnter:${path}` });\n    const hatchUpdate = domain.createEvent<HatchParams>({ name: `hatchUpdate:${path}` });\n    const hatchExit = domain.createEvent<void>({ name: `hatchExit:${path}` });\n\n    const componentHatch = getHatch(component);\n    if (componentHatch) {\n      forward({ from: hatchEnter, to: componentHatch.enter });\n      forward({ from: hatchUpdate, to: componentHatch.update });\n      forward({ from: hatchExit, to: componentHatch.exit });\n    }\n\n    // Shows that user is on the route\n    const $onRoute = domain.createStore(false, { name: `$onRoute:${path}` });\n\n    // Shows that user visited route and waited for page\n    // If true, page.hatch.enter is triggered and logic was run\n    const $onPage = domain.createStore(false, { name: `$onPage:${path}` });\n\n    //#region route matched\n    $onRoute.on(routeMatched, () => true);\n\n    guard({\n      clock: routeMatched,\n      filter: $onPage,\n      target: hatchUpdate,\n    });\n\n    guard({\n      clock: routeMatched,\n      filter: combine($onPage, $onRoute, (page, route) => !page && route),\n      target: hatchEnter,\n    });\n\n    $onPage.on(hatchEnter, () => true);\n    //#endregion route matched\n\n    //#region NOT matched\n    $onRoute.on(notMatched, () => false);\n\n    guard({\n      clock: notMatched,\n      filter: $onPage,\n      target: hatchExit,\n    });\n\n    $onPage.on(hatchExit, () => false);\n    //#endregion NOT matched\n  }\n\n  return { navigation };\n}\n","import { Domain, sample, scopeBind } from 'effector';\nimport { createBrowserHistory, createMemoryHistory } from 'history';\n\nexport interface HistoryChange {\n  pathname: string;\n  hash: string;\n  search: string;\n  action: 'PUSH' | 'POP' | 'REPLACE';\n}\n\nexport function createNavigation(\n  domain: Domain,\n  { emitHistory = false, trackRedirects = false } = {},\n) {\n  const history = typeof document !== 'undefined' ? createBrowserHistory() : createMemoryHistory();\n\n  const historyPush = domain.createEffect<string, void>(() => {});\n  const historyPushSearch = domain.createEffect<string, void>(() => {});\n  const historyReplace = domain.createEffect<string, void>(() => {});\n\n  const historyChanged = domain.createEvent<HistoryChange>();\n\n  const historyEmitCurrent = domain.createEvent();\n\n  const $redirectTo = domain.createStore('');\n\n  // do not actual change history, just trigger history changed with correct arguments\n  sample({\n    clock: historyEmitCurrent,\n    fn: () =>\n      ({\n        action: 'REPLACE',\n        hash: history.location.hash,\n        pathname: history.location.pathname,\n        search: history.location.search,\n      } as HistoryChange),\n    target: historyChanged,\n  });\n\n  if (emitHistory) {\n    historyPush.use((url) => history.push(url));\n    historyReplace.use((url) => history.replace(url));\n    historyPushSearch.use((search) => history.push({ search }));\n\n    historyEmitCurrent.watch(() => {\n      let historyChangedBound: (payload: HistoryChange) => void;\n      try {\n        historyChangedBound = scopeBind(historyChanged);\n      } catch (_) {\n        historyChangedBound = (p) => historyChanged(p);\n      }\n\n      history.listen(({ pathname, search, hash }, action) => {\n        historyChangedBound({ pathname, search, hash, action });\n      });\n    });\n  }\n\n  if (trackRedirects) {\n    $redirectTo.on([historyPush, historyReplace], (_, url) => url);\n    if (emitHistory) {\n      $redirectTo.on(historyChanged, (_, { pathname, search }) => `${pathname}?${search}`);\n    }\n  }\n\n  return {\n    history,\n    historyPush,\n    historyPushSearch,\n    historyReplace,\n    historyChanged,\n    historyEmitCurrent,\n    $redirectTo,\n  };\n}\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { Unit, forward, is } from 'effector';\n\ntype KeysOfEffectorApi<API> = {\n  [KEY in keyof API]: API[KEY] extends Unit<any> ? KEY : never;\n}[keyof API];\n\nexport function contract<\n  Properties extends string,\n  Page extends Record<Properties, unknown>\n>(config: { page: Page; model: Pick<Page, KeysOfEffectorApi<Page>> }) {\n  for (const name in config.page) {\n    const pageUnit = config.page[name];\n\n    // Workaround for typescript\n    // We're already proofed by type system that user should pass\n    // each property to model object for page API.\n    // Each property that don't implements Effector API must be excluded\n    const modelUnit = (config.model as Page)[name];\n\n    // Typically we can import page like this:\n    // import * as page from './page'\n    // And there will be React-component in the list of properties\n    // is.unit omit it\n    if (pageUnit && modelUnit && is.unit(pageUnit) && is.unit(modelUnit)) {\n      // Stores has an unique data flow: from model to page\n      // When store in the model is changed, we want to change the store in the page too\n      // But we don't want to change store from the page's code\n      if (is.store(pageUnit) && is.store(modelUnit)) {\n        forward({ from: modelUnit, to: pageUnit });\n\n        pageUnit.defaultState = modelUnit.defaultState;\n\n        // Change current state\n        (pageUnit as any).stateRef.current = (modelUnit as any).stateRef.current;\n\n        // Change initial state inside scope\n        // https://t.me/c/1489066599/4652\n        (pageUnit as any).stateRef.before = [\n          {\n            type: 'map',\n            fn: (state: unknown) => state,\n            from: (modelUnit as any).stateRef,\n          },\n        ];\n      }\n      // Typical data flow: from page to model\n      // When something happened in the page (event is triggered)\n      // We want to trigger the same event in the model to start our logic\n      // But model can trigger the event too\n      // Typically we don't want to subscribe to events in the page\n      else {\n        forward({ from: pageUnit, to: modelUnit });\n      }\n    }\n  }\n}\n","import { createDomain } from 'effector';\n\nexport const defaultDomain = createDomain('framework/default');\n","import loadable from '@loadable/component';\nimport { RouteConfig, renderRoutes } from 'react-router-config';\n\nexport { createBrowserApplication } from './browser-application';\nexport { createHatch, getHatch, withHatch, lookupHatch } from './hatch';\nexport type { Hatch, HatchParams } from './hatch';\n\nexport { contract } from './contract';\n\nexport const createPages = (routes: RouteConfig[]) => renderRoutes(routes);\n\nexport { loadable };\nexport type { RouteConfig };\n"],"names":["splitMap","_ref","source","cases","result","current","is","store","name","sid","updates","key","_fn","filterMap","filter","fn","data","__","createHatch","config_","defaultDomain","domain","config","$opened","createStore","Boolean","$params","$query","hatch","enter","createEvent","update","exit","$props","combine","params","query","on","_","reset","withHatch","component","HATCH","getHatch","lookupHatch","match","route","createBrowserApplication","navigation","emitHistory","trackRedirects","history","document","createBrowserHistory","createMemoryHistory","historyPush","createEffect","historyPushSearch","historyReplace","historyChanged","historyEmitCurrent","$redirectTo","sample","clock","action","hash","location","pathname","search","target","use","url","push","replace","watch","historyChangedBound","scopeBind","p","listen","createNavigation","forward","from","ready","to","routeResolved","change","routes","matchRoutes","length","path","load","Error","routeMatched","notMatched","Object","fromEntries","URLSearchParams","hatchEnter","hatchUpdate","hatchExit","componentHatch","$onRoute","$onPage","guard","page","contract","pageUnit","modelUnit","model","unit","defaultState","stateRef","before","type","state","createDomain","createPages","renderRoutes"],"mappings":"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"}